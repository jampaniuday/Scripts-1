From:	Holesek, Jakob
Sent:	18 October 2017 15:02
To:	DL-GGL-Database-Performance; Allen, Roger
Cc:	Stagg, Richard-XT; Tedjo, Winarko; Dedeler, Gokhan-XT
Subject:	SIOUG 2017 Oracle Conference 

Categories:	Red Category

Hi all,

It was a great conference, learnt a few new things and re-learnt some old ones.
Here are some of the more interesting things:
1)	Histograms
a.	With default setting for gathering stat – "for all columns size auto" – you can get 
histograms on not just the skewed columns. You can use dbms_stats.report_col_usage 
to check the usage and if it is RANGE, then histogram will be created.
b.	There are new types of histograms in 12c, most notably "hybrid histogram", presenting 
frequency histogram of popular values.
c.	If you got histograms at some point and you are not confident to drop them and want to 
maintain just the ones you have, you can set "FOR ALL COLUMNS SIZE REPEAT". This 
stops working correctly in 12.1 as it doesn't add buckets.
d.	As a side note, the 12c documentation has a "Oracle Database SQL Tuning Guide" with 
lots of nice pictures one can include in the presentations or explanation documents.
2)	Consolidated AWR History Repository
a.	You should build the consolidated repository on a highest database version possible. It 
can't include data from databases above the consolidated database version.
b.	Oracle OEM 12c can orchestrate the data being transported into such repository 
(including 11g targets visible in the OEM).
c.	Once OEM is aware of the consolidated repository you can select it within OEM and 
work with all the tools in OEM. It is also possible to provide reports comparing non-
related databases (making AWR diff reports from two databases, not just two snapshots 
from the dame database).
3)	Tablespaces – back to basics
a.	Multi Block Read process can read from one extent at the time only. Having data 
scattered over a large number of extents will slow down reads.
b.	DATA_OBJECT_ID in DBA_OBJECTS points to the object id blocks in 
datafiles/tablespaces. OBJECT_ID is the logical ID of the object.
i.	MOVE command will move segments to the end of the datafiles (extending 
them if needed) and change the data_object_id. The old blocks are not deleted, 
just marked as not being used.
ii.	SHRINK table command will move blocks to the start of segment, condensing 
the used space. It keeps same data_object_id and requires row movement 
enabled.
iii.	DELETE command marks row as deleted in the header, it doesn't delete the 
data.
iv.	TRUNCATE just created a new data_object_id and leaves the orphaned blocks to 
be reused later
c.	There is an open source tool available which can show you (ANSI graphic, terminal one) 
where the blocks of your object are in the datafile.
4)	News about 12.2.0.1
a.	Oracle is changing the release numbering. Release will be yearly ones, then quarterly 
updates and release update revisions. So the next database version will be 18.1 and 
should be released in January 2018.
b.	Oracle Support MOS note 742060.1 shows the patch roadmap. @Roger, it includes a 
very nice Oracle version roadmap with support details, including the extended free 
support for 11.2.0.4 until end of 2018.
c.	Things of note from 12.1 already:
i.	DataGuard Far Sync
1.	Keeping dataguard in synchronous mode over a large distance, by 
introducing a proxy in between. So DG keeps strict sync to the proxy 
and then allows for asynch to the far end.
ii.	Data Redaction
1.	Ability to mask data dynamically, on the fly, based on rules.
iii.	JSON document store
1.	Storing JSON documents so that they can be queried like tables (much 
like it was possible with XML already).
d.	Interesting things from 12.2:
i.	Pluggable database hot clone, from live database. And then doing SnapClones 
from it. PDB can be refreshed later, not just dropped and rebuilt. 
ii.	You can relocate a PDB to another 12c database online as well – moving to new 
hosts etc.
iii.	PDB can be configured for a lock down isolation, preventing access from it to 
the main container database.
iv.	In-Memory:
1.	Creating a join group with indexes for in-memory tables
2.	Using virtual columns for expressions for the in-memory table
3.	You can use in-memory on Active Dataguard Instance
4.	On Exadata it can spill onto flash cache if so configured
v.	AWR repository and reports are now possible on the PDB level, not just at the 
container database level
vi.	You can now push SQL Advisor to work on ADG instance and not the primary 
one
vii.	Online tablespace encryption, no need to move data to the new tablespace if 
you want it encrypted.
viii.	It will be possible to create Analytic Views, effectively using views to construct 
OLAP cubes.
ix.	Optimizer is made Big Data aware and so can optimize queries where tables 
from noSQL and SQL part are used.
5)	Ensure Performance when upgrading
a.	Presentation given by Mike Dietrich, " Master Product Manager – Database Upgrades & 
Migrations"
b.	MOS note having details and links to upgrade information: Oracle Database (RDBMS) 
Releases Support Status Summary (Doc ID 161818.1)
c.	You should patch to the latest level on the new release before upgrading. Based on 
escalation data from support, almost 70-80% of the issues during upgrades were 
addressed by the latest patches.
d.	There is also a MOS note regarding optimizer issues and fixes when migrating to oracle 
versions. The links is in the presentation which was not uploaded to the conference side 
yet. I'll send an update.
e.	Testing pre-migration/upgrade:
i.	Collect execution plans into SQL Tuning Advisor set
ii.	Transfer the set to the migration test database
iii.	If owning a Real Application Testing licence, you can use SQL Performance 
Analyzer which reports the plan differences changes and points to the reasons 
why. You can then make config changes, gather stats, make sql profiles etc. and 
repeat the process. This doesn't require a full SQL replay to be done, just 
running the SQL Performance Analyzer.
iv.	Without RAT licence it gets harder to compare the plans, so something manually 
needs to be done/prepared.
6)	What causes execution plan changes by Optimizer?
a.	Optimizer considers about 2000 possibilities. 5 table join has over 30 million 
possibilities.
b.	One of the reasons why plan may change is also it gets flushed out of the shared pool. 
When that happens, all feedbacks (cardinality or statistics – you can see this in the 
Notes section of the explain plan) are lost. And the optimizer looks at the plan a new.
c.	You can see in the V$SQL_SHARED_CURSOR if the child cursor (and different execution 
plan) was used due to the feedback (colun USE_FEEDBACK_STATS)
d.	Statistics Decay – once you get out of the known range for the low and high values of 
the column, the row estimates drop quickly. If you are off the range by the whole range, 
it gets to 0.
e.	Dynamic Sampling uses 64 random blocks from the table with the default setting of 
DYNAMIC_SAMPLING 2.
i.	With 4 it reads 64 blocks for all tables joined by complex predicates (like 
column1+column2, multiple AND and ORs)
ii.	With settings 5-9 it gets up to 4096 blocks
iii.	Values 10 causes a full table scan before the execution plan is built
f.	Bind Variable Peeking 
i.	In V$SQL column IS_BIND_AWARE you can see if the plan used is bind aware 
and bind variable peeking was used. It also shows that in the Notes section of 
the execution plans. The column IS_BIND_SENSITIVE would show if the database 
is aware that this plan should be used with these binds only.
ii.	The database will tend to keep the same execution plan for a sql id even if the 
next set of bind variables would be better served with a different execution 
plan. The only way to enable two active plans per sql statement seems to be by 
implementing the SQL baselines – or to make sqls using different data sets to be 
different by putting comments or small changes into the sql statements.
g.	Adaptive Execution Plans
i.	Oracle 12c introduces adaptive execution plans, allowing optimizer to change 
the execution plan WHILE the sql is running, based on the actual rows retrieved 
etc. It can switch from planned NESTED LOOP to HASH JOIN based on the 
feedback, for instance.
ii.	The feature works well in 12.2
iii.	You can use "+adaptive" directive to get the execution plan showing used and 
unused lines from the plan
h.	Even when index is not used by the execution plan, it may be references by the 
optimizer while preparing the plan. That's why dropping an otherwise unused index may 
cause the change in plan – optimizer used the details of columns from the index stats.
i.	Besides SQL Profiles, there is also an option of SQL Patches, which allows a single 140 
characters hint to be pushed to a sql statement. It's an internal function in 11g 
(dbms_sqldiag_internal package) and becomes a proper usable function in 12c.

This is what I found interesting and worth sharing. When presentations will become available I'll share 
those as well.

Thanks and Regards,
  Jakob Holesek

Tel: 1931-78053 ; Chat: holesekj

